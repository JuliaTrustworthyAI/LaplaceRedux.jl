var documenterSearchIndex = {"docs":
[{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"CurrentModule = LaplaceRedux","category":"page"},{"location":"tutorials/mlp/#Bayesian-MLP","page":"MLP Binary Classifier","title":"Bayesian MLP","text":"","category":"section"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"This time we use a synthetic dataset containing samples that are not linearly separable:","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"# Number of points to generate.\nxs, ys = LaplaceRedux.Data.toy_data_non_linear(200)\nX = hcat(xs...) # bring into tabular format\ndata = zip(xs,ys)","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"For the classification task we build a neural network with weight decay composed of a single hidden layer.","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"n_hidden = 10\nD = size(X,1)\nnn = Chain(\n    Dense(D, n_hidden, œÉ),\n    Dense(n_hidden, 1)\n)  \nloss(x, y) = Flux.Losses.logitbinarycrossentropy(nn(x), y) ","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"The model is trained until training loss stagnates.","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"using Flux.Optimise: update!, Adam\nopt = Adam(1e-3)\nepochs = 100\navg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\nshow_every = epochs/10\n\nfor epoch = 1:epochs\n  for d in data\n    gs = gradient(Flux.params(nn)) do\n      l = loss(d...)\n    end\n    update!(opt, Flux.params(nn), gs)\n  end\n  if epoch % show_every == 0\n    println(\"Epoch \" * string(epoch))\n    @show avg_loss(data)\n  end\nend","category":"page"},{"location":"tutorials/mlp/#Laplace-Approximation","page":"MLP Binary Classifier","title":"Laplace Approximation","text":"","category":"section"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"Laplace approximation can be implemented as follows:","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"la = Laplace(nn; likelihood=:classification, subset_of_weights=:all)\nfit!(la, data)\nla_untuned = deepcopy(la)   # saving for plotting\noptimize_prior!(la; verbose=true, n_steps=500)","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"The plot below shows the resulting posterior predictive surface for the plugin estimator (left) and the Laplace approximation (right).","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"# Plot the posterior distribution with a contour plot.\nzoom=0\np_plugin = plot(la, X, ys; title=\"Plugin\", link_approx=:plugin, clim=(0,1))\np_untuned = plot(la_untuned, X, ys; title=\"LA - raw (Œª=$(unique(diag(la_untuned.P‚ÇÄ))[1]))\", clim=(0,1), zoom=zoom)\np_laplace = plot(la, X, ys; title=\"LA - tuned (Œª=$(round(unique(diag(la.P‚ÇÄ))[1],digits=2)))\", clim=(0,1), zoom=zoom)\nplot(p_plugin, p_untuned, p_laplace, layout=(1,3), size=(1700,400))","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"(Image: )","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"Zooming out we can note that the plugin estimator produces high-confidence estimates in regions scarce of any samples. The Laplace approximation is much more conservative about these regions.","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"zoom=-50\np_plugin = plot(la, X, ys; title=\"Plugin\", link_approx=:plugin, clim=(0,1))\np_untuned = plot(la_untuned, X, ys; title=\"LA - raw (Œª=$(unique(diag(la_untuned.P‚ÇÄ))[1]))\", clim=(0,1), zoom=zoom)\np_laplace = plot(la, X, ys; title=\"LA - tuned (Œª=$(round(unique(diag(la.P‚ÇÄ))[1],digits=2)))\", clim=(0,1), zoom=zoom)\nplot(p_plugin, p_untuned, p_laplace, layout=(1,3), size=(1700,400))","category":"page"},{"location":"tutorials/mlp/","page":"MLP Binary Classifier","title":"MLP Binary Classifier","text":"(Image: )","category":"page"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"CurrentModule = LaplaceRedux","category":"page"},{"location":"tutorials/logit/#Bayesian-Logistic-Regression","page":"Logistic Regression","title":"Bayesian Logistic Regression","text":"","category":"section"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"We will use synthetic data with linearly separable samples:","category":"page"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"# Number of points to generate.\nxs, ys = LaplaceRedux.Data.toy_data_linear(100)\nX = hcat(xs...) # bring into tabular format\ndata = zip(xs,ys)","category":"page"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"Logistic regression with weight decay can be implemented in Flux.jl as a single dense (linear) layer with binary logit crossentropy loss:","category":"page"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"nn = Chain(Dense(2,1))\nŒª = 0.5\nsqnorm(x) = sum(abs2, x)\nweight_regularization(Œª=Œª) = 1/2 * Œª^2 * sum(sqnorm, Flux.params(nn))\nloss(x, y) = Flux.Losses.logitbinarycrossentropy(nn(x), y) + weight_regularization()","category":"page"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"The code below simply trains the model. After about 50 training epochs training loss stagnates.","category":"page"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"using Flux.Optimise: update!, Adam\nopt = Adam()\nepochs = 50\navg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\nshow_every = epochs/10\n\nfor epoch = 1:epochs\n  for d in data\n    gs = gradient(Flux.params(nn)) do\n      l = loss(d...)\n    end\n    update!(opt, Flux.params(nn), gs)\n  end\n  if epoch % show_every == 0\n    println(\"Epoch \" * string(epoch))\n    @show avg_loss(data)\n  end\nend","category":"page"},{"location":"tutorials/logit/#Laplace-approximation","page":"Logistic Regression","title":"Laplace approximation","text":"","category":"section"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"Laplace approximation for the posterior predictive can be implemented as follows:","category":"page"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"la = Laplace(nn; likelihood=:classification, Œª=Œª, subset_of_weights=:last_layer)\nfit!(la, data)\nla_untuned = deepcopy(la)   # saving for plotting\noptimize_prior!(la; verbose=true, n_steps=500)","category":"page"},{"location":"tutorials/logit/","page":"Logistic Regression","title":"Logistic Regression","text":"The plot below shows the resulting posterior predictive surface for the plugin estimator (left) and the Laplace approximation (right).","category":"page"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"CurrentModule = LaplaceRedux","category":"page"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"note: In Progress\n","category":"page"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"¬†¬†¬†¬†This documentation is still incomplete.","category":"page"},{"location":"tutorials/prior/#A-quick-note-on-the-prior","page":"A note on the prior ...","title":"A quick note on the prior","text":"","category":"section"},{"location":"tutorials/prior/#General-Effect","page":"A note on the prior ...","title":"General Effect","text":"","category":"section"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"High prior precision ‚Üí only observation noise. Low prior precision ‚Üí high posterior uncertainty.","category":"page"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"using LaplaceRedux.Data\nn = 150       # number of observations\nœÉtrue = 0.30  # true observational noise\nx, y = Data.toy_data_regression(n;noise=œÉtrue)\nxs = [[x] for x in x]\nX = permutedims(x)","category":"page"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"(Image: )","category":"page"},{"location":"tutorials/prior/#Effect-of-Model-Size-on-Optimal-Choice","page":"A note on the prior ...","title":"Effect of Model Size on Optimal Choice","text":"","category":"section"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"For larger models, the optimal prior precision Œª as evaluated through Empirical Bayes tends to be smaller.","category":"page"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"(Image: )","category":"page"},{"location":"tutorials/prior/","page":"A note on the prior ...","title":"A note on the prior ...","text":"(Image: )","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"CurrentModule = LaplaceRedux","category":"page"},{"location":"tutorials/regression/#Data","page":"MLP Regression","title":"Data","text":"","category":"section"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"We first generate some synthetic data:","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"using LaplaceRedux.Data\nn = 300       # number of observations\nœÉtrue = 0.30  # true observational noise\nx, y = Data.toy_data_regression(n;noise=œÉtrue)\nxs = [[x] for x in x]\nX = permutedims(x)","category":"page"},{"location":"tutorials/regression/#MLP","page":"MLP Regression","title":"MLP","text":"","category":"section"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"We set up a model and loss with weight regularization:","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"data = zip(xs,y)\nn_hidden = 50\nD = size(X,1)\nnn = Chain(\n    Dense(D, n_hidden, tanh),\n    Dense(n_hidden, 1)\n)  \nloss(x, y) = Flux.Losses.mse(nn(x), y)","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"We train the model:","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"using Flux.Optimise: update!, Adam\nopt = Adam(1e-3)\nepochs = 1000\navg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\nshow_every = epochs/10\n\nfor epoch = 1:epochs\n  for d in data\n    gs = gradient(Flux.params(nn)) do\n      l = loss(d...)\n    end\n    update!(opt, Flux.params(nn), gs)\n  end\n  if epoch % show_every == 0\n    println(\"Epoch \" * string(epoch))\n    @show avg_loss(data)\n  end\nend","category":"page"},{"location":"tutorials/regression/#Laplace-Approximation","page":"MLP Regression","title":"Laplace Approximation","text":"","category":"section"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"Laplace approximation can be implemented as follows:","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"subset_w = :all\nla = Laplace(nn; likelihood=:regression, subset_of_weights=subset_w)\nfit!(la, data)\nplot(la, X, y; zoom=-5, size=(400,400))","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"(Image: )","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"Next we optimize the prior precision P‚ÇÄ and and observational noise œÉ using Empirical Bayes:","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"optimize_prior!(la; verbose=true)\nplot(la, X, y; zoom=-5, size=(400,400))","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"loss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 115.89970006409075\nLog likelihood: -78.9395891640363\nLog det ratio: 41.59099583534049\nScatter: 32.329225964768405\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 117.64871821240808\nLog likelihood: -86.21271638531181\nLog det ratio: 47.02391032864642\nScatter: 15.848093325546113\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 99.0503686829033\nLog likelihood: -68.6539632244081\nLog det ratio: 50.50904634071264\nScatter: 10.283764576277756\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 97.95806446351698\nLog likelihood: -67.6630665366047\nLog det ratio: 52.31062172238063\nScatter: 8.27937413144392\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 97.87638521130879\nLog likelihood: -67.56210824487965\nLog det ratio: 52.99651119671768\nScatter: 7.632042736140583\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 97.0348007783304\nLog likelihood: -66.71699326917162\nLog det ratio: 53.06607882969837\nScatter: 7.569536188619179\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 96.90880533777283\nLog likelihood: -66.60043898495907\nLog det ratio: 52.86479666828444\nScatter: 7.751936037343088\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 96.92278577215899\nLog likelihood: -66.62313517903836\nLog det ratio: 52.601352698984954\nScatter: 7.997948487256308\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 96.90753961129343\nLog likelihood: -66.6118899797289\nLog det ratio: 52.382272284239775\nScatter: 8.20902697888927\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 96.8946599908052\nLog likelihood: -66.59997317019008\nLog det ratio: 52.24377877042417\nScatter: 8.345594870806066","category":"page"},{"location":"tutorials/regression/","page":"MLP Regression","title":"MLP Regression","text":"(Image: )","category":"page"},{"location":"tutorials/multi/#Multi-class-problem","page":"MLP Multi-Label Classifier","title":"Multi-class problem","text":"","category":"section"},{"location":"tutorials/multi/","page":"MLP Multi-Label Classifier","title":"MLP Multi-Label Classifier","text":"using LaplaceRedux.Data\nx, y = Data.toy_data_multi()\nX = hcat(x...)\ny_train = Flux.onehotbatch(y, unique(y))\ny_train = Flux.unstack(y_train',1)","category":"page"},{"location":"tutorials/multi/","page":"MLP Multi-Label Classifier","title":"MLP Multi-Label Classifier","text":"data = zip(x,y_train)\nn_hidden = 3\nD = size(X,1)\nout_dim = length(unique(y))\nnn = Chain(\n    Dense(D, n_hidden, œÉ),\n    Dense(n_hidden, out_dim)\n)  \nloss(x, y) = Flux.Losses.logitcrossentropy(nn(x), y)","category":"page"},{"location":"tutorials/multi/","page":"MLP Multi-Label Classifier","title":"MLP Multi-Label Classifier","text":"using Flux.Optimise: update!, Adam\nopt = Adam()\nepochs = 100\navg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\nshow_every = epochs/10\n\nfor epoch = 1:epochs\n    for d in data\n        gs = gradient(Flux.params(nn)) do\n            l = loss(d...)\n        end\n        update!(opt, Flux.params(nn), gs)\n    end\n    if epoch % show_every == 0\n        println(\"Epoch \" * string(epoch))\n        @show avg_loss(data)\n    end\nend","category":"page"},{"location":"tutorials/multi/#Laplace-Approximation","page":"MLP Multi-Label Classifier","title":"Laplace Approximation","text":"","category":"section"},{"location":"tutorials/multi/","page":"MLP Multi-Label Classifier","title":"MLP Multi-Label Classifier","text":"la = Laplace(nn; likelihood=:classification)\nfit!(la, data)\noptimize_prior!(la; verbose=true, n_steps=100)","category":"page"},{"location":"tutorials/multi/","page":"MLP Multi-Label Classifier","title":"MLP Multi-Label Classifier","text":"_labels = sort(unique(y))\nplt_list = []\nfor target in _labels\n    plt = plot(la, X, y; target=target, clim=(0,1))\n    push!(plt_list, plt)\nend\nplot(plt_list...)","category":"page"},{"location":"tutorials/multi/","page":"MLP Multi-Label Classifier","title":"MLP Multi-Label Classifier","text":"(Image: )","category":"page"},{"location":"tutorials/multi/","page":"MLP Multi-Label Classifier","title":"MLP Multi-Label Classifier","text":"_labels = sort(unique(y))\nplt_list = []\nfor target in _labels\n    plt = plot(la, X, y; target=target, clim=(0,1), link_approx=:plugin)\n    push!(plt_list, plt)\nend\nplot(plt_list...)","category":"page"},{"location":"tutorials/multi/","page":"MLP Multi-Label Classifier","title":"MLP Multi-Label Classifier","text":"(Image: )","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = LaplaceRedux","category":"page"},{"location":"reference/#All-functions-and-types","page":"Reference","title":"All functions and types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Exported-functions","page":"Reference","title":"Exported functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [\n    LaplaceRedux,\n    LaplaceRedux.Curvature,\n    LaplaceRedux.Data,\n]\nPrivate = false","category":"page"},{"location":"reference/#LaplaceRedux.Laplace-Tuple{Any}","page":"Reference","title":"LaplaceRedux.Laplace","text":"Laplace(model::Any; loss_fun::Union{Symbol, Function}, kwargs...)\n\nWrapper function to prepare Laplace approximation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.LaplaceApproximation-Union{Tuple{}, Tuple{L}, Tuple{O}, Tuple{F}, Tuple{B}} where {B, F, O, L}","page":"Reference","title":"LaplaceRedux.LaplaceApproximation","text":"LaplaceApproximation(; builder::B, finaliser::F, optimiser::O, loss::L, epochs::Int, batchsize::Int, lambda::Float64, alpha::Float64, rng::Union{AbstractRNG,Int64}, optimiserchangestriggerretraining::Bool, acceleration::AbstractResource, likelihood::Symbol, subsetofweights::Symbol, subnetworkindices::Vector{Vector{Int}}, hessianstructure::Symbol, backend::Symbol, œÉ::Float64, Œº‚ÇÄ::Float64, P‚ÇÄ::Union{AbstractMatrix,UniformScaling}, linkapprox::Symbol, fitparams::Dict{Symbol,Any}, ) where {B,F,O,L}\n\nConstructor for LaplaceApproximation, a wrapper for Laplace, a bayesian deep learning model.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.fit!-Tuple{LaplaceRedux.BaseLaplace, Any}","page":"Reference","title":"LaplaceRedux.fit!","text":"fit!(la::BaseLaplace,data)\n\nFits the Laplace approximation for a data set. The function returns the number of observations (n_data) that were used to update the Laplace object. It does not return the updated Laplace object itself because the function modifies the input Laplace object in place (as denoted by the use of '!' in the function's name).\n\nExamples\n\nusing Flux, LaplaceRedux\nx, y = LaplaceRedux.Data.toy_data_linear()\ndata = zip(x,y)\nnn = Chain(Dense(2,1))\nla = Laplace(nn)\nfit!(la, data)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.fit!-Tuple{LaplaceRedux.BaseLaplace, MLUtils.DataLoader}","page":"Reference","title":"LaplaceRedux.fit!","text":"Fit the Laplace approximation, with batched data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.glm_predictive_distribution-Tuple{LaplaceRedux.BaseLaplace, AbstractArray}","page":"Reference","title":"LaplaceRedux.glm_predictive_distribution","text":"glm_predictive_distribution(la::BaseLaplace, X::AbstractArray)\n\nComputes the linearized GLM predictive.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.optimize_prior!-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux.optimize_prior!","text":"optimize_prior!(\n    la::BaseLaplace; \n    n_steps::Int=100, lr::Real=1e-1,\n    Œªinit::Union{Nothing,Real}=nothing,\n    œÉinit::Union{Nothing,Real}=nothing\n)\n\nOptimize the prior precision post-hoc through Empirical Bayes (marginal log-likelihood maximization).\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.posterior_covariance","page":"Reference","title":"LaplaceRedux.posterior_covariance","text":"posterior_covariance(la::BaseLaplace, P=la.P)\n\nComputes the posterior covariance  as the inverse of the posterior precision: Sigma=P^-1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LaplaceRedux.posterior_precision","page":"Reference","title":"LaplaceRedux.posterior_precision","text":"posterior_precision(la::BaseLaplace)\n\nComputes the posterior precision P for a fitted Laplace Approximation as follows,\n\nP = sum_n=1^Nnabla_theta^2log p(mathcalD_ntheta)_theta_MAP + nabla_theta^2 log p(theta)_theta_MAP\n\nwhere sum_n=1^Nnabla_theta^2log p(mathcalD_ntheta)_theta_MAP=H and nabla_theta^2 log p(theta)_theta_MAP=P_0.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LaplaceRedux.predict-Tuple{LaplaceRedux.BaseLaplace, AbstractArray}","page":"Reference","title":"LaplaceRedux.predict","text":"predict(la::BaseLaplace, X::AbstractArray; link_approx=:probit, predict_proba::Bool=true)\n\nComputes predictions from Bayesian neural network.\n\nExamples\n\nusing Flux, LaplaceRedux\nx, y = toy_data_linear()\ndata = zip(x,y)\nnn = Chain(Dense(2,1))\nla = Laplace(nn)\nfit!(la, data)\npredict(la, hcat(x...))\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.predict-Tuple{LaplaceRedux.BaseLaplace, Matrix}","page":"Reference","title":"LaplaceRedux.predict","text":"Compute predictive posteriors for a batch of inputs.\n\nNote, input is assumed to be batched only if it is a matrix. If the input dimensionality of the model is 1 (a vector), one should still prepare a 1√óB matrix batch as input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Internal-functions","page":"Reference","title":"Internal functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [\n    LaplaceRedux,\n    LaplaceRedux.Curvature,\n    LaplaceRedux.Data,\n]\nPublic = false","category":"page"},{"location":"reference/#LaplaceRedux.BaseLaplace","page":"Reference","title":"LaplaceRedux.BaseLaplace","text":"Abstract base type for all Laplace approximations in this library\n\n\n\n\n\n","category":"type"},{"location":"reference/#LaplaceRedux.BaseLaplace-Tuple{AbstractArray}","page":"Reference","title":"LaplaceRedux.BaseLaplace","text":"(la::BaseLaplace)(X::AbstractArray; kwrgs...)\n\nCalling a model with Laplace Approximation on an array of inputs is equivalent to explicitly calling the predict function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux._H_factor-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux._H_factor","text":"_H_factor(la::BaseLaplace)\n\nReturns the factor œÉ‚Åª¬≤, where œÉ is used in the zero-centered Gaussian prior p(Œ∏) = N(Œ∏;0,œÉ¬≤I)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux._init_H-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux._init_H","text":"_init_H(la::BaseLaplace)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux._weight_penalty-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux._weight_penalty","text":"_weight_penalty(la::BaseLaplace)\n\nThe weight penalty term is a regularization term used to prevent overfitting. Weight regularization methods such as weight decay introduce a penalty to the loss function when training a neural network to encourage the network to use small weights. Smaller weights in a neural network can result in a model that is more stable and less likely to overfit the training dataset, in turn having better performance when  making a prediction on new data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.convert_subnetwork_indices-Tuple{Vector{Vector{Int64}}, AbstractArray}","page":"Reference","title":"LaplaceRedux.convert_subnetwork_indices","text":"convertsubnetworkindices(subnetwork_indices::AbstractArray)\n\nConverts the subnetwork indices from the user given format [theta, row, column] to an Int i that corresponds to the index of that weight in the flattened array of weights.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.functional_variance-Tuple{Laplace, Any}","page":"Reference","title":"LaplaceRedux.functional_variance","text":"functional_variance(la::Laplace,ùêâ)\n\nCompute the linearized GLM predictive variance as ùêâ‚ÇôŒ£ùêâ‚Çô' where ùêâ=‚àáf(x;Œ∏)|Œ∏ÃÇ is the Jacobian evaluated at the MAP estimate and Œ£ = P‚Åª¬π.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.functional_variance-Tuple{LaplaceRedux.KronLaplace, Matrix}","page":"Reference","title":"LaplaceRedux.functional_variance","text":"functional_variance(la::KronLaplace, ùêâ::Matrix)\n\nCompute functional variance for the GLM predictive: as the diagonal of the K√óK predictive output covariance matrix ùêâùêè‚Åª¬πùêâ·µÄ, where K is the number of outputs, ùêè is the posterior precision, and ùêâ is the Jacobian of model output ùêâ=‚àáf(x;Œ∏)|Œ∏ÃÇ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.get_loss_fun-Tuple{Symbol, Flux.Chain}","page":"Reference","title":"LaplaceRedux.get_loss_fun","text":"get_loss_fun(likelihood::Symbol)\n\nHelper function to choose loss function based on specified model likelihood.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.get_loss_type-Tuple{Symbol, Flux.Chain}","page":"Reference","title":"LaplaceRedux.get_loss_type","text":"get_loss_type(likelihood::Symbol)\n\nChoose loss function type based on specified model likelihood.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.get_params-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux.get_params","text":"get_params(la::BaseLaplace)\n\nRetrieves the desired (sub)set of model parameters and stores them in a list.\n\nExamples\n\nusing Flux, LaplaceRedux\n# define a neural network with one hidden layer that takes a two-dimensional input and produces a one-dimensional output\nnn = Chain(Dense(2,1))\nla = Laplace(nn)\nLaplaceRedux.get_params(la)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.hessian_approximation-Tuple{LaplaceRedux.BaseLaplace, Any}","page":"Reference","title":"LaplaceRedux.hessian_approximation","text":"hessian_approximation(la::BaseLaplace, d; batched::Bool=false)\n\nComputes the local Hessian approximation at a single datapoint d.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.inv_square_form-Tuple{LaplaceRedux.Curvature.KronDecomposed, Matrix}","page":"Reference","title":"LaplaceRedux.inv_square_form","text":"function invsquareform(K::KronDecomposed, W::Matrix)\n\nSpecial function to compute the inverse square form ùêâùêè‚Åª¬πùêâ·µÄ (or ùêñùêä‚Åª¬πùêñ·µÄ)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.log_det_posterior_precision-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux.log_det_posterior_precision","text":"log_det_posterior_precision(la::BaseLaplace)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.log_det_prior_precision-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux.log_det_prior_precision","text":"log_det_prior_precision(la::BaseLaplace)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.log_det_ratio-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux.log_det_ratio","text":"log_det_ratio(la::BaseLaplace)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.log_likelihood-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux.log_likelihood","text":"log_likelihood(la::BaseLaplace)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.log_marginal_likelihood-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux.log_marginal_likelihood","text":"log_marginal_likelihood(la::BaseLaplace; P‚ÇÄ::Union{Nothing,UniformScaling}=nothing, œÉ::Union{Nothing, Real}=nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.outdim-Tuple{Flux.Chain}","page":"Reference","title":"LaplaceRedux.outdim","text":"outdim(model::Chain)\n\nHelper function to determine the output dimension of a Flux.Chain, corresponding to the number of neurons on the last layer of the NN.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.outdim-Tuple{LaplaceRedux.BaseLaplace}","page":"Reference","title":"LaplaceRedux.outdim","text":"outdim(la::BaseLaplace)\n\nHelper function to determine the output dimension, corresponding to the number of neurons  on the last layer of the NN, of a Flux.Chain with Laplace approximation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.validate_subnetwork_indices-Tuple{Union{Nothing, Vector{Vector{Int64}}}, Any}","page":"Reference","title":"LaplaceRedux.validate_subnetwork_indices","text":"validatesubnetworkindices( subnetwork_indices::Union{Nothing,Vector{Vector{Int}}}, params )\n\nDetermines whether subnetwork_indices is a valid input for specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.@def-Tuple{Any, Any}","page":"Reference","title":"LaplaceRedux.@def","text":"Compile-time copy-paste macro @def: a macro that creates a macro with the specified name and content, which is then immediately applied to the code.\n\nRef: https://www.stochasticlifestyle.com/type-dispatch-design-post-object-oriented-programming-julia/\n\n\n\n\n\n","category":"macro"},{"location":"reference/#LaplaceRedux.Curvature.CurvatureInterface","page":"Reference","title":"LaplaceRedux.Curvature.CurvatureInterface","text":"Basetype for any curvature interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LaplaceRedux.Curvature.EmpiricalFisher","page":"Reference","title":"LaplaceRedux.Curvature.EmpiricalFisher","text":"Constructor for curvature approximated by empirical Fisher.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LaplaceRedux.Curvature.GGN","page":"Reference","title":"LaplaceRedux.Curvature.GGN","text":"Constructor for curvature approximated by Generalized Gauss-Newton.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LaplaceRedux.Curvature.Kron","page":"Reference","title":"LaplaceRedux.Curvature.Kron","text":"Kronecker-factored approximate curvature representation for a neural network model. Each element in kfacs represents two Kronecker factors (ùêÜ, ùêÄ), such that the full block Hessian approximation would be approximated as ùêÄ‚äóùêÜ.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LaplaceRedux.Curvature.KronDecomposed","page":"Reference","title":"LaplaceRedux.Curvature.KronDecomposed","text":"Decomposed Kronecker-factored approximate curvature representation for a neural network model.\n\nDecomposition is required to add the prior (diagonal matrix) to the posterior (KronDecomposed). It also has the benefits of reducing the costs for computation of inverses and log-determinants.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:*-Tuple{LaplaceRedux.Curvature.KronDecomposed, Number}","page":"Reference","title":"Base.:*","text":"Multiply by a scalar by changing the eigenvalues. Distribute the scalar along the factors of a block.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{Real, LaplaceRedux.Curvature.Kron}","page":"Reference","title":"Base.:*","text":"Kronecker-factored curvature scalar scaling.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:+-Tuple{LaplaceRedux.Curvature.Kron, LaplaceRedux.Curvature.Kron}","page":"Reference","title":"Base.:+","text":"Kronecker-factored curvature sum.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:+-Tuple{LaplaceRedux.Curvature.KronDecomposed, LinearAlgebra.Diagonal}","page":"Reference","title":"Base.:+","text":"Shift the factors by a diagonal (assumed uniform scaling)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:+-Tuple{LaplaceRedux.Curvature.KronDecomposed, Number}","page":"Reference","title":"Base.:+","text":"Shift the factors by a scalar across the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:==-Tuple{LaplaceRedux.Curvature.Kron, LaplaceRedux.Curvature.Kron}","page":"Reference","title":"Base.:==","text":"Kronecker-factored curvature equality.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getindex-Tuple{LaplaceRedux.Curvature.Kron, Int64}","page":"Reference","title":"Base.getindex","text":"Get Kronecker-factored block represenation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getindex-Tuple{LaplaceRedux.Curvature.KronDecomposed, Int64}","page":"Reference","title":"Base.getindex","text":"Get i-th block of a a Kronecker-factored curvature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.length-Tuple{LaplaceRedux.Curvature.KronDecomposed}","page":"Reference","title":"Base.length","text":"Number of blocks in a Kronecker-factored curvature.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.clamp-Tuple{LinearAlgebra.Eigen}","page":"Reference","title":"LaplaceRedux.Curvature.clamp","text":"Clamp eigenvalues in an eigendecomposition to be non-negative.\n\nSince the Fisher information matrix is a positive-semidefinite by construction, the (near-zero) negative eigenvalues should be neglected.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.decompose-Tuple{LaplaceRedux.Curvature.Kron}","page":"Reference","title":"LaplaceRedux.Curvature.decompose","text":"decompose(K::Kron)\n\nEigendecompose Kronecker factors and turn into KronDecomposed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.full-Tuple{LaplaceRedux.Curvature.CurvatureInterface, Tuple}","page":"Reference","title":"LaplaceRedux.Curvature.full","text":"full(curvature::CurvatureInterface, d::Tuple; batched::Bool=false)\n\nCompute the full approximation, for either a single input-output datapoint or a batch of such. \n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.full_batched-Tuple{LaplaceRedux.Curvature.EmpiricalFisher, Tuple}","page":"Reference","title":"LaplaceRedux.Curvature.full_batched","text":"full_batched(curvature::EmpiricalFisher, d::Tuple)\n\nCompute the full empirical Fisher for batch of inputs-outputs, with the batch dimension at the end.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.full_batched-Tuple{LaplaceRedux.Curvature.GGN, Tuple}","page":"Reference","title":"LaplaceRedux.Curvature.full_batched","text":"full_batched(curvature::GGN, d::Tuple)\n\nCompute the full GGN for batch of inputs-outputs, with the batch dimension at the end.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.full_unbatched-Tuple{LaplaceRedux.Curvature.EmpiricalFisher, Tuple}","page":"Reference","title":"LaplaceRedux.Curvature.full_unbatched","text":"full_unbatched(curvature::EmpiricalFisher, d::Tuple)\n\nCompute the full empirical Fisher for a single datapoint.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.full_unbatched-Tuple{LaplaceRedux.Curvature.GGN, Tuple}","page":"Reference","title":"LaplaceRedux.Curvature.full_unbatched","text":"full_unbatched(curvature::GGN, d::Tuple)\n\nCompute the full GGN for a singular input-ouput datapoint. \n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.gradients-Tuple{LaplaceRedux.Curvature.CurvatureInterface, AbstractArray, Union{Number, AbstractArray}}","page":"Reference","title":"LaplaceRedux.Curvature.gradients","text":"gradients(curvature::CurvatureInterface, X::AbstractArray, y::Number)\n\nCompute the gradients with respect to the loss function: ‚àá‚Ñì(f(x;Œ∏),y) where f: ‚Ñù·¥∞ ‚Ü¶ ‚Ñù·¥∑.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.interleave-Tuple","page":"Reference","title":"LaplaceRedux.Curvature.interleave","text":"Interleave elements of multiple iterables in order provided.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.jacobians-Tuple{LaplaceRedux.Curvature.CurvatureInterface, AbstractArray}","page":"Reference","title":"LaplaceRedux.Curvature.jacobians","text":"jacobians(curvature::CurvatureInterface, X::AbstractArray; batched::Bool=false)\n\nComputes the Jacobian ‚àáf(x;Œ∏) where f: ‚Ñù·¥∞ ‚Ü¶ ‚Ñù·¥∑.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.jacobians_batched-Tuple{LaplaceRedux.Curvature.CurvatureInterface, AbstractArray}","page":"Reference","title":"LaplaceRedux.Curvature.jacobians_batched","text":"jacobians_batched(curvature::CurvatureInterface, X::AbstractArray)\n\nCompute Jacobians of the model output w.r.t. model parameters for points in X, with batching.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.jacobians_unbatched-Tuple{LaplaceRedux.Curvature.CurvatureInterface, AbstractArray}","page":"Reference","title":"LaplaceRedux.Curvature.jacobians_unbatched","text":"jacobians_unbatched(curvature::CurvatureInterface, X::AbstractArray)\n\nCompute the Jacobian of the model output w.r.t. model parameters for the point X, without batching. Here, the nn function is wrapped in an anonymous function using the () -> syntax, which allows it to be differentiated using automatic differentiation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.kron-Tuple{LaplaceRedux.Curvature.CurvatureInterface, Any}","page":"Reference","title":"LaplaceRedux.Curvature.kron","text":"Compute the eigendecomposed Kronecker-factored approximate curvature as the Fisher information matrix.\n\nNote, since the network predictive distribution is used in a weighted sum, and the number of backward passes is linear in the number of target classes, e.g. 100 for CIFAR-100.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.logdetblock-Tuple{Tuple{LinearAlgebra.Eigen, LinearAlgebra.Eigen}, Number}","page":"Reference","title":"LaplaceRedux.Curvature.logdetblock","text":"logdetblock(block::Tuple{Eigen,Eigen}, delta::Number)\n\nLog-determinant of a block in KronDecomposed, shifted by delta by on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.mm-Tuple{LaplaceRedux.Curvature.KronDecomposed, Any}","page":"Reference","title":"LaplaceRedux.Curvature.mm","text":"Matrix-multuply for the KronDecomposed Hessian approximation K and a 2-d matrix W, applying an exponent to K and transposing W before multiplication. Return (K^x)W^T, where x is the exponent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearAlgebra.det-Tuple{LaplaceRedux.Curvature.KronDecomposed}","page":"Reference","title":"LinearAlgebra.det","text":"det(K::KronDecomposed)\n\nLog-determinant of the KronDecomposed block-diagonal matrix, as the exponentiated log-determinant.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearAlgebra.logdet-Tuple{LaplaceRedux.Curvature.KronDecomposed}","page":"Reference","title":"LinearAlgebra.logdet","text":"logdet(K::KronDecomposed)\n\nLog-determinant of the KronDecomposed block-diagonal matrix, as the product of the determinants of the blocks\n\n\n\n\n\n","category":"method"},{"location":"reference/#LaplaceRedux.Curvature.@zb-Tuple{Any}","page":"Reference","title":"LaplaceRedux.Curvature.@zb","text":"Macro for zero-based indexing. Example of usage: (@zb A[0]) = ...\n\n\n\n\n\n","category":"macro"},{"location":"reference/#LaplaceRedux.Data.toy_data_linear","page":"Reference","title":"LaplaceRedux.Data.toy_data_linear","text":"toy_data_linear(N=100)\n\nExamples\n\ntoy_data_linear()\n\n\n\n\n\n","category":"function"},{"location":"reference/#LaplaceRedux.Data.toy_data_multi","page":"Reference","title":"LaplaceRedux.Data.toy_data_multi","text":"toy_data_multi(N=100)\n\nExamples\n\ntoy_data_multi()\n\n\n\n\n\n","category":"function"},{"location":"reference/#LaplaceRedux.Data.toy_data_non_linear","page":"Reference","title":"LaplaceRedux.Data.toy_data_non_linear","text":"toy_data_non_linear(N=100)\n\nExamples\n\ntoy_data_non_linear()\n\n\n\n\n\n","category":"function"},{"location":"reference/#LaplaceRedux.Data.toy_data_regression","page":"Reference","title":"LaplaceRedux.Data.toy_data_regression","text":"toy_data_regression(N=25, p=1; noise=0.3, fun::Function=f(x)=sin(2 * œÄ * x))\n\nA helper function to generate synthetic data for regression.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LaplaceRedux","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for LaplaceRedux.jl.","category":"page"},{"location":"#LaplaceRedux","page":"Home","title":"LaplaceRedux","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LaplaceRedux.jl is a library written in pure Julia that can be used for effortless Bayesian Deep Learning through Laplace Approximation (LA). In the development of this package I have drawn inspiration from this Python library and its companion paper (Daxberger et al. 2021).","category":"page"},{"location":"#Installation","page":"Home","title":"üö© Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The stable version of this package can be installed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"LaplaceRedux.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The development version can be installed like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/JuliaTrustworthyAI/LaplaceRedux.jl\")","category":"page"},{"location":"#Getting-Started","page":"Home","title":"üèÉ Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are new to Deep Learning in Julia or simply prefer learning through videos, check out this awesome YouTube tutorial by doggo.jl üê∂. Additionally, you can also find a video of my presentation at JuliaCon 2022 on YouTube.","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"üñ•Ô∏è Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LaplaceRedux.jl can be used for any neural network trained in Flux.jl. Below we show basic usage examples involving two simple models for a regression and a classification task, respectively.","category":"page"},{"location":"#Regression","page":"Home","title":"Regression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A complete worked example for a regression model can be found in the docs. Here we jump straight to Laplace Approximation and take the pre-trained model nn as given. Then LA can be implemented as follows, where we specify the model likelihood. The plot shows the fitted values overlaid with a 95% confidence interval. As expected, predictive uncertainty quickly increases in areas that are not populated by any training data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"la = Laplace(nn; likelihood=:regression)\nfit!(la, data)\noptimize_prior!(la)\nplot(la, X, y; zoom=-5, size=(500,500))","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Binary-Classification","page":"Home","title":"Binary Classification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once again we jump straight to LA and refer to the docs for a complete worked example involving binary classification. In this case we need to specify likelihood=:classification. The plot below shows the resulting posterior predictive distributions as contours in the two-dimensional feature space: note how the Plugin Approximation on the left compares to the Laplace Approximation on the right.","category":"page"},{"location":"","page":"Home","title":"Home","text":"la = Laplace(nn; likelihood=:classification)\nfit!(la, data)\nla_untuned = deepcopy(la)   # saving for plotting\noptimize_prior!(la; n_steps=100)\n\n# Plot the posterior predictive distribution:\nzoom=0\np_plugin = plot(la, X, ys; title=\"Plugin\", link_approx=:plugin, clim=(0,1))\np_untuned = plot(la_untuned, X, ys; title=\"LA - raw (Œª=$(unique(diag(la_untuned.P‚ÇÄ))[1]))\", clim=(0,1), zoom=zoom)\np_laplace = plot(la, X, ys; title=\"LA - tuned (Œª=$(round(unique(diag(la.P‚ÇÄ))[1],digits=2)))\", clim=(0,1), zoom=zoom)\nplot(p_plugin, p_untuned, p_laplace, layout=(1,3), size=(1700,400))","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#JuliaCon-2022","page":"Home","title":"üì¢ JuliaCon 2022","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project was presented at JuliaCon 2022 in July 2022. See here for details.","category":"page"},{"location":"#Contribute","page":"Home","title":"üõ†Ô∏è Contribute","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are very much welcome! Please follow the SciML ColPrac guide. You may want to start by having a look at any open issues.","category":"page"},{"location":"#References","page":"Home","title":"üéì References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Daxberger, Erik, Agustinus Kristiadi, Alexander Immer, Runa Eschenhagen, Matthias Bauer, and Philipp Hennig. 2021. ‚ÄúLaplace Redux-Effortless Bayesian Deep Learning.‚Äù Advances in Neural Information Processing Systems 34.","category":"page"},{"location":"resources/_resources/#Additional-Resources","page":"Additional Resources","title":"Additional Resources","text":"","category":"section"},{"location":"resources/_resources/#JuliaCon-2022","page":"Additional Resources","title":"JuliaCon 2022","text":"","category":"section"},{"location":"resources/_resources/","page":"Additional Resources","title":"Additional Resources","text":"Slides: link","category":"page"},{"location":"resources/_resources/","page":"Additional Resources","title":"Additional Resources","text":"<iframe style=\"width:560px;height:315px\" src=\"https://www.paltmeyer.com/LaplaceRedux.jl/dev/resources/juliacon22/presentation.html\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"}]
}
