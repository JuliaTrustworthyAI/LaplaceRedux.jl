<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calibrated forecasts · LaplaceRedux.jl</title><meta name="title" content="Calibrated forecasts · LaplaceRedux.jl"/><meta property="og:title" content="Calibrated forecasts · LaplaceRedux.jl"/><meta property="twitter:title" content="Calibrated forecasts · LaplaceRedux.jl"/><meta name="description" content="Documentation for LaplaceRedux.jl."/><meta property="og:description" content="Documentation for LaplaceRedux.jl."/><meta property="twitter:description" content="Documentation for LaplaceRedux.jl."/><meta property="og:url" content="https://juliatrustworthyai.github.io/LaplaceRedux.jl/tutorials/calibration/"/><meta property="twitter:url" content="https://juliatrustworthyai.github.io/LaplaceRedux.jl/tutorials/calibration/"/><link rel="canonical" href="https://juliatrustworthyai.github.io/LaplaceRedux.jl/tutorials/calibration/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="LaplaceRedux.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LaplaceRedux.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../logit/">Logistic Regression</a></li><li><a class="tocitem" href="../mlp/">MLP Binary Classifier</a></li><li><a class="tocitem" href="../multi/">MLP Multi-Label Classifier</a></li><li><a class="tocitem" href="../regression/">MLP Regression</a></li><li><a class="tocitem" href="../prior/">A note on the prior ...</a></li><li class="is-active"><a class="tocitem" href>Calibrated forecasts</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#The-issue-of-calibrated-uncertainty-distributions"><span>The issue of calibrated uncertainty distributions</span></a></li><li><a class="tocitem" href="#Notation"><span>Notation</span></a></li><li><a class="tocitem" href="#Calibration-in-the-Regression-case"><span>Calibration in the Regression case</span></a></li><li><a class="tocitem" href="#Calibration-in-the-Binary-Classification-case"><span>Calibration in the Binary Classification case</span></a></li><li><a class="tocitem" href="#Calibration-Plots-2"><span>Calibration Plots</span></a></li><li><a class="tocitem" href="#Multiclass-Case"><span>Multiclass Case</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><a class="tocitem" href="../../mlj_interface/">MLJ interface</a></li><li><a class="tocitem" href="../../resources/_resources/">Additional Resources</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Calibrated forecasts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calibrated forecasts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTrustworthyAI/LaplaceRedux.jl/blob/main/docs/src/tutorials/calibration.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Uncertainty-Calibration"><a class="docs-heading-anchor" href="#Uncertainty-Calibration">Uncertainty Calibration</a><a id="Uncertainty-Calibration-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-Calibration" title="Permalink"></a></h1><h1 id="The-issue-of-calibrated-uncertainty-distributions"><a class="docs-heading-anchor" href="#The-issue-of-calibrated-uncertainty-distributions">The issue of calibrated uncertainty distributions</a><a id="The-issue-of-calibrated-uncertainty-distributions-1"></a><a class="docs-heading-anchor-permalink" href="#The-issue-of-calibrated-uncertainty-distributions" title="Permalink"></a></h1><p>Bayesian methods offer a general framework for quantifying uncertainty. However, due to model misspecification and the use of approximate inference techniques,uncertainty estimates are often inaccurate: for example, a 90% credible interval may not contain the true outcome 90% of the time, in such cases the model is said to be miscalibrated. This problem arises due to the limitations of the model itself: a predictor may not be sufficiently expressive to assign the right probability to every credible interval, just as it may not be able to always assign the right label to a datapoint. Miscalibrated credible intervals reduce the trustworthiness of the forecaster because they lead to a false sense of precision and either overconfidence or underconfidence in the results.</p><p>A forecaster is said to be perfectly calibrated if a 90% credible interval contains the true outcome approximately 90% of the time. Perfect calibration however cannot be achieved with limited data, because with limited data comes inherent statistical fluctuations that can cause the estimated credible intervals to deviate from the ideal coverage probability. Furthermore, a finite sample of collected data points cannot eliminate completely the influence of the possible misjudged prior probabilities. On top of these issues, which stem directly from Bayes’ theorem, with Bayesian neural networks there is also the problems introduced by the approximate inference method adopted to compute the posterior distribution of the weights.</p><p>To introduce the concept of Average Calibration and the Calibration Plots, we will follow closely the paper <a href="https://arxiv.org/abs/1807.00263">Accurate Uncertainties for Deep Learning Using Calibrated Regression</a>, written by Volodymyr Kuleshov, Nathan Fenner and Stefano Ermon, although with some small differences. We will hightlight these differences in the following paragraphs whenever they appear. We present here the theoretical basis necessary to understand the issue of calibration and we refer to the tutorials for the coding examples.</p><h2 id="Notation"><a class="docs-heading-anchor" href="#Notation">Notation</a><a id="Notation-1"></a><a class="docs-heading-anchor-permalink" href="#Notation" title="Permalink"></a></h2><p>We are given a labeled dataset <span>$x_t, y_t \in X \times Y$</span> for <span>$t = 1, 2, ..., T$</span> of i.i.d. realizations of random variables <span>$X, Y \sim P$</span>, where <span>$P$</span> is the data distribution. Given <span>$x_t$</span>, a forecaster <span>$H : X \rightarrow (Y \rightarrow [0, 1])$</span> outputs at each step <span>$t$</span> a CDF <span>$F_t(y)$</span> targeting the label <span>$y_t$</span>. When <span>$Y$</span> is continuous, <span>$F_t$</span> is a cumulative probability distribution (CDF). We will use <span>$F^{−1}_t: [0, 1] → Y$</span> to denote the quantile function <span>$F^{−1}_t (p) = inf\{y : p ≤ F_t(y)\}$</span>.</p><h2 id="Calibration-in-the-Regression-case"><a class="docs-heading-anchor" href="#Calibration-in-the-Regression-case">Calibration in the Regression case</a><a id="Calibration-in-the-Regression-case-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-in-the-Regression-case" title="Permalink"></a></h2><p>In the regression case, we say that the forecaster H is (on average) calibrated if</p><p class="math-container">\[\frac{\sum_{t=1}^T \mathbb{1} \{ y_t \leq F_t^{-1}(p)  \} }{T} \rightarrow p \quad \text{for all}\quad  p \in [0,1]\]</p><p>as <span>$T \rightarrow \infty$</span>.  In other words, the empirical and the predicted CDFs should match as the dataset size goes to infinity. Perfect Calibration is a sufficient condition for average calibration, the opposite however is not necessarily true: a model can be average calibrated but not perfectly calibrated.   From now on when we talk about calibration we will implicitly talk about average calibration rather than perfect calibration.</p><h3 id="Sharpness"><a class="docs-heading-anchor" href="#Sharpness">Sharpness</a><a id="Sharpness-1"></a><a class="docs-heading-anchor-permalink" href="#Sharpness" title="Permalink"></a></h3><p>Calibration by itself is not sufficient to produce a useful forecast. For example, it is easy to see that if we use for the forecast the marginal distribution <span>$F(y) = \mathbb{P}(Y ≤ y)$</span>, without considering the input feature <span>$X$</span>, the forecast will be calibrated but still not accurate. In order to be useful, forecasts must also be sharp, which (in a regression context) means that the confidence intervals should all be as tight as possible around a single value. More formally, we want the variance <span>$var(F_t)$</span> of the random variable whose CDF is <span>$F_t$</span> to be small.   As a sharpness score of the forecaster, Kuleshov et al. proposed the average predicted variance</p><p class="math-container">\[sharpness(F_{1} ,\dots, F_T) = \frac{1}{T} \sum_{t=1}^T var{F_t}\]</p><p>the smaller the sharpness, the tighter will be the confidence intervals on average.</p><h3 id="Calibration-Plots"><a class="docs-heading-anchor" href="#Calibration-Plots">Calibration Plots</a><a id="Calibration-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-Plots" title="Permalink"></a></h3><p>To check the level of calibration, Kuleshov et al. proposed a calibration plot that displays the true frequency of points in each confidence interval relative to the predicted fraction of points in that interval.   More formally, we choose <span>$m$</span> confidence levels <span>$0 ≤ p_1 &lt; p_2 &lt; . . . &lt; p_m ≤ 1$</span>; for each threshold <span>$p_j$</span> , and compute the empirical frequency</p><p class="math-container">\[\hat{p}_j = \frac{|\{ y_t|F_t(y_t) \leq p_t, t= 1,2,\dots,T    \} |}{T}.\]</p><p>To visualize the level of average calibration, we plot <span>$\{(p_j,\hat{p_j}) \}_{j=1}^M$</span>; A forecaster that is calibrated will correspond to a straight line on the plot that goes from <span>$\{0,0\}$</span> to <span>$\{1,1\}$</span> .   o measure the level of miscalibration, we can compute the area between the diagonal line (the line of perfect calibration) and the calibration curve produced by the forecaster. This area represents the degree to which the predicted probabilities deviate from the actual observed frequencies. Alternatively, the original paper suggests using the calibration error as a numerical score to describe the quality of forecast calibration: <span>$cal(F_1,F_2,\dots,F_T,y_T) = \sum_{j=1}^m w_j (p_j -\hat{p}_j)^2$</span> where the scalars <span>$w_j$</span> are tunable weights. Both methods — using the area between the calibration curve and the diagonal line or using the calibration error — are equivalent in that they both provide a numerical measure of miscalibration. The calibration error can be seen as a discretized approximation of the area, where the weights <span>$𝑤_𝑗$</span> adjust for the distribution of samples across different bins.</p><h3 id="Post-training-calibration"><a class="docs-heading-anchor" href="#Post-training-calibration">Post-training calibration</a><a id="Post-training-calibration-1"></a><a class="docs-heading-anchor-permalink" href="#Post-training-calibration" title="Permalink"></a></h3><p>As we have said previously, uncertainty estimates obtained by deep BNNs tend to be miscalibrated. We introduced the support to a post-training technique for regression problems presented in <a href="https://arxiv.org/abs/2104.12376">Recalibration of Aleatoric and Epistemic Regression Uncertainty in Medical Imaging</a> by Max-Heinrich Laves, Sontje Ihler, Jacob F. Fast, Lüder A. Kahrs and Tobias Ortmaier and usually referred to as sigma-scaling. Using a Gaussian model, the technique consist in scaling the predicted standard deviation <span>$\sigma$</span> with a scalar value <span>$s$</span> to recalibrate the probability density function</p><p class="math-container">\[p(y|x; \hat{y}(x), \hat{σ}^2(x)) = \mathbb{N}( y; \hat{y}(x),(s  \cdot  \hat{σ}(x))^2 ).\]</p><p>This results in the following minimization objective:</p><p class="math-container">\[L_G(s) = m \log(s) + \frac{1}{2}s^{−2} \sum_{i=1}^m (\hat{σ}^{(i)}_θ)^{−2} || y^{(i)} − \hat{y}_{\theta}^{(i)}||^2.\]</p><p>In general, this equation can be optimized respect to <span>$s$</span> with fixed values for the parameters <span>$\theta$</span> using gradient descent in a second phase over a separate calibration set. However, for the case of a gaussian distribution, the analytical solution is known and takes the closed form</p><p class="math-container">\[s = \pm \sqrt{\frac{1}{m} \sum_{i=1}^m (\hat{σ}^{(i)}_θ)^{−2} || y^{(i)} − \hat{y}_{\theta}^{(i)}||^2}.\]</p><p>Once the scalar <span>$s$</span> is computed, all we have to do to obtain better calibrated predictions is to multiply the predicted standard deviation with the scalar. The main difference from the other supported technique for optimization of the uncertainty estimates, which is based on Empirical Bayes, is that sigma-scaling tries to optimize directly the posterior predictive distribution using a separate calibration dataset. Empirical Bayes instead involves estimating the parameters of the prior distribution by maximizing the marginal likelihood of the observed data, effectively finding a prior that best explains the data without needing a separate calibration dataset. Empirical Bayes uses the observed data itself to indirectly improve the calibration of uncertainty estimates by refining the prior, whereas sigma-scaling focuses on a direct post-hoc adjustment to the posterior predictive uncertainty.</p><h2 id="Calibration-in-the-Binary-Classification-case"><a class="docs-heading-anchor" href="#Calibration-in-the-Binary-Classification-case">Calibration in the Binary Classification case</a><a id="Calibration-in-the-Binary-Classification-case-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration-in-the-Binary-Classification-case" title="Permalink"></a></h2><p>In binary classification, we have <span>$Y = {0, 1}$</span>, and we say that H is calibrated if</p><p class="math-container">\[\frac{\sum_{t=1}^{T} y_t\mathbb{1}\{H(x_t)=p\}}{\sum_{t=1}^{T}\mathbb{1}\{H(x_t)=p\}} \rightarrow p \quad \text{for all} \quad p\in [0,1]\]</p><p>as <span>$T \rightarrow \infty$</span>. For simplicity, we have denoted <span>$H(x_t)$</span> as the probability of the event <span>$y_t=1$</span>. Once again, perfect calibration is a sufficient condition for calibration.</p><h3 id="Sharpness-2"><a class="docs-heading-anchor" href="#Sharpness-2">Sharpness</a><a class="docs-heading-anchor-permalink" href="#Sharpness-2" title="Permalink"></a></h3><p>We can assess sharpness by looking at the distribution of model predictions. When forecasts are sharp, most predicted probabilities for the correct class are close to <span>$1$</span>; unsharp forecasters make predictions closer to <span>$0.5$</span>.</p><h2 id="Calibration-Plots-2"><a class="docs-heading-anchor" href="#Calibration-Plots-2">Calibration Plots</a><a class="docs-heading-anchor-permalink" href="#Calibration-Plots-2" title="Permalink"></a></h2><p>Given a dataset <span>${(x_t, y_t)}^T_t=1$</span>, let <span>$p_t = H(x_t) ∈ [0, 1]$</span> be the forecasted probability. We group the <span>$p_t$</span> into intervals <span>$I_j$</span> for <span>$j = 1, 2, ..., m$</span> that form a partition of <span>$[0, 1]$</span>.   A calibration curve plots the predicted average <span>$</span> p<em>j = T^{−1}*j *{t:p</em>t∈ I<em>j} p</em>t <span>$</span> in each interval <span>$I_j$</span> against the observed empirical average <span>$p_j = T^{−1}_j \sum_{t:p_t ∈ I_j}y_t,$</span> where <span>$T_j = |{t : p_t ∈ I_j}|$</span>. Perfect calibration corresponds once again to a straight line.</p><h2 id="Multiclass-Case"><a class="docs-heading-anchor" href="#Multiclass-Case">Multiclass Case</a><a id="Multiclass-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Multiclass-Case" title="Permalink"></a></h2><p>For multiclass classification tasks the above technique can be extended by plotting each class versus all the remaining classes considered as one.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../prior/">« A note on the prior ...</a><a class="docs-footer-nextpage" href="../../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 7 November 2024 04:40">Thursday 7 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
