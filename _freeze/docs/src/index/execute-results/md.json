{
  "hash": "b9ccb333a18be1f46dee29b57ce312f5",
  "result": {
    "markdown": "```@meta\nCurrentModule = LaplaceRedux\n```\n\n# LaplaceRedux\n\nDocumentation for [LaplaceRedux.jl](https://github.com/pat-alt/LaplaceRedux.jl).\n\n\n\n`LaplaceRedux.jl` is a library written in pure Julia that can be used for effortless Bayesian Deep Learning trough Laplace Approximation (LA). In the development of this package I have drawn inspiration from this Python [library](https://aleximmer.github.io/Laplace/index.html#setup) and its companion [paper](https://arxiv.org/abs/2106.14806) [@daxberger2021laplace].\n\n## üö© Installation\n\nThe stable version of this package can be installed as follows:\n\n```{.julia}\nusing Pkg\nPkg.add(\"LaplaceRedux.jl\")\n```\n\nThe development version can be installed like so:\n\n```{.julia}\nusing Pkg\nPkg.add(\"https://github.com/pat-alt/LaplaceRedux.jl\")\n```\n\n## üñ•Ô∏è Basic Usage\n\n`LaplaceRedux.jl` can be used for any neural network trained in [`Flux.jl`](https://fluxml.ai/Flux.jl/dev/). Below we show basic usage examples involving two simple models for a regression and a classification task, respectively.\n\n### Regression\n\n\n\nA complete worked example for a regression model can be found in the [docs](https://www.paltmeyer.com/LaplaceRedux.jl/dev/tutorials/regression/). Here we jump straight to Laplace Approximation and take the pre-trained model `nn` as given. Then LA can be implemented as follows, where we specify the model `likelihood`. The plot show the fitted values overlayed with a 95% confidence interval. As expected, predictive uncertainty quickly increases in areas that are not populated by any training data.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nla = Laplace(nn; likelihood=:regression)\nfit!(la, data)\noptimize_prior!(la)\nplot(la, X, y; zoom=-5, size=(400,400))\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-commonmark/cell-4-output-1.svg){}\n:::\n:::\n\n\n### Binary Classification\n\n\n\nOnce again we jump straight to LA and refer to the [docs](https://www.paltmeyer.com/LaplaceRedux.jl/dev/tutorials/mlp/) for a complete worked example involving binary classification. In this case we need to specify `likelihood=:classification`. The plot below shows the resulting posterior predictive distributions as contours in the two-dimensional feature space: note how the **Plugin** Approximation on the left compares to the Laplace Approximation on the right.\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nla = Laplace(nn; likelihood=:classification)\nfit!(la, data)\nla_untuned = deepcopy(la)   # saving for plotting\noptimize_prior!(la; verbose=true, n_steps=500)\n\n# Plot the posterior predictive distribution:\nzoom=0\np_plugin = plot(la, X, ys; title=\"Plugin\", link_approx=:plugin, clim=(0,1))\np_untuned = plot(la_untuned, X, ys; title=\"LA - raw (Œª=$(unique(diag(la_untuned.P‚ÇÄ))[1]))\", clim=(0,1), zoom=zoom)\np_laplace = plot(la, X, ys; title=\"LA - tuned (Œª=$(round(unique(diag(la.P‚ÇÄ))[1],digits=2)))\", clim=(0,1), zoom=zoom)\nplot(p_plugin, p_untuned, p_laplace, layout=(1,3), size=(1700,400))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 50: P‚ÇÄ=0.06080220040262144, œÉ=1.0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 25.700731337819576\nIteration 100: P‚ÇÄ=0.03864448374363554, œÉ=1.0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.385333791169938\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 150: P‚ÇÄ=0.03407170744815622, œÉ=1.0\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.300861656631366\nIteration 200: P‚ÇÄ=0.03291185032022732, œÉ=1.0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.295534970827646\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 250: P‚ÇÄ=0.032685898252189316, œÉ=1.0\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.295354166355335\nIteration 300: P‚ÇÄ=0.032658417387831706, œÉ=1.0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.29535183069232\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 350: P‚ÇÄ=0.03265709523177021, œÉ=1.0\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.2953518263952\nIteration 400: P‚ÇÄ=0.03265717759247646, œÉ=1.0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.2953518263726\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nIteration 450: P‚ÇÄ=0.032657184624387665, œÉ=1.0\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.295351826372727\nIteration 500: P‚ÇÄ=0.03265718403952106, œÉ=1.0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nloss(exp.(logP‚ÇÄ), exp.(logœÉ)) = 24.295351826372492\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](index_files/figure-commonmark/cell-6-output-12.svg){}\n:::\n:::\n\n\n## üì¢ JuliaCon 2022\n\nThis project was presented at JuliaCon 2022 in July 2022. See [here](https://pretalx.com/juliacon-2022/talk/Z7MXFS/) for details.\n\n## üõ†Ô∏è Contribute\n\nContributions are very much welcome! Please follow the [SciML ColPrac guide](https://github.com/SciML/ColPrac). You may want to start by having a look at any open issues. \n\n\n## ‚ùé Known Limitations\n\nThis library currently offers native support only for models composed and trained in Flux. It also still lacks out-of-the-box support for hyperparameter tuning. \n\n## üéì References\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": []
  }
}